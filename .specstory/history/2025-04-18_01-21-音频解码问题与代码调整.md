<!-- Generated by SpecStory -->

# éŸ³é¢‘è§£ç é—®é¢˜ä¸ä»£ç è°ƒæ•´ (2025-04-18 09:21:07)

_**User**_

@test æˆ‘ä¿®æ”¹äº†å‰æ®µçš„æµ‹è¯•çš„htmlå†…å®¹ï¼Œç„¶åé‡æ–°æµ‹è¯•äº†ä¸€ä¸‹ã€‚æ— æ³•æ­£ç¡®è§£æå†…å®¹ã€‚
[09:23:26.871] éŸ³é¢‘ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ
[09:23:33.275] å‘é€æ–‡æœ¬æ¶ˆæ¯: ä½ å¥½
[09:23:33.279] è¯†åˆ«ç»“æœ: ä½ å¥½
[09:23:33.280] å¤§æ¨¡å‹å›å¤: ğŸ˜Š
[09:23:33.289] æœåŠ¡å™¨å¼€å§‹å‘é€è¯­éŸ³
[09:23:36.095] æœªçŸ¥æ¶ˆæ¯ç±»å‹: tts_mp3
[09:23:36.112] å¼€å§‹éŸ³é¢‘ç¼“å†²...
[09:23:36.122] æœªçŸ¥æ¶ˆæ¯ç±»å‹: tts_mp3
[09:23:36.414] ç¼“å†²è¶…æ—¶ï¼Œå½“å‰ç¼“å†²åŒ…æ•°: 1ï¼Œå¼€å§‹æ’­æ”¾
[09:23:36.433] Opusè§£ç é”™è¯¯: Opusè§£ç å¤±è´¥: -4
[09:23:36.434] æ²¡æœ‰æˆåŠŸè§£ç çš„æ ·æœ¬
[09:23:36.436] æœªçŸ¥æ¶ˆæ¯ç±»å‹: tts_mp3
[09:23:36.450] æœªçŸ¥æ¶ˆæ¯ç±»å‹: tts_mp3
[09:23:36.895] æœªçŸ¥æ¶ˆæ¯ç±»å‹: tts_mp3
[09:23:36.920] æœªçŸ¥æ¶ˆæ¯ç±»å‹: tts_mp3
[09:23:36.923] æœªçŸ¥æ¶ˆæ¯ç±»å‹: tts_mp3
[09:23:36.944] æœªçŸ¥æ¶ˆæ¯ç±»å‹: tts_mp3

å¸®æˆ‘æ£€æŸ¥ä¸‹ç›¸å…³ä»£ç å¹¶åšäº›è°ƒæ•´ã€‚å¹¶ç»™ä½ é™„ä¸ŠæœåŠ¡ç«¯çš„æ—¥è®°å‚è€ƒã€‚

---

_**Assistant**_



---

å¥½çš„ï¼Œæˆ‘æ¥æ£€æŸ¥ä¸€ä¸‹ `test_page.html` æ–‡ä»¶ä¸­çš„ç›¸å…³ä»£ç ï¼Œçœ‹çœ‹ä¸ºä»€ä¹ˆæ— æ³•æ­£ç¡®å¤„ç† `tts_mp3` æ¶ˆæ¯ã€‚æ ¹æ®ä½ æä¾›çš„æ—¥å¿—ï¼Œå‰ç«¯ä¼¼ä¹æ”¶åˆ°äº† `tts_mp3` ç±»å‹çš„æ¶ˆæ¯ï¼Œä½†å°†å…¶æ ‡è®°ä¸ºæœªçŸ¥ç±»å‹ï¼Œå¹¶ä¸”åœ¨å°è¯•è§£ç éŸ³é¢‘æ—¶é‡åˆ°äº† Opus è§£ç é”™è¯¯ã€‚è¿™è¡¨æ˜å‰ç«¯çš„ WebSocket æ¶ˆæ¯å¤„ç†é€»è¾‘å¯èƒ½æ²¡æœ‰åŒ…å«å¯¹ `tts_mp3` ç±»å‹çš„å¤„ç†ï¼Œæˆ–è€…éŸ³é¢‘è§£ç éƒ¨åˆ†é…ç½®ä¸æ­£ç¡®ï¼ˆä¾‹å¦‚ï¼ŒæœŸæœ› Opus æ ¼å¼ä½†æ”¶åˆ°äº† MP3ï¼‰ã€‚

æˆ‘å°†å…ˆè¯»å– `test_page.html` æ–‡ä»¶å†…å®¹ï¼Œåˆ†æå…¶ä¸­çš„ JavaScript ä»£ç ã€‚


---

Read file: main/xiaozhi-server/test/test_page.html

---

æ–‡ä»¶æ¯”è¾ƒå¤§ï¼Œåªè¯»å–äº†å‰ 250 è¡Œã€‚çœ‹èµ·æ¥è¿™éƒ¨åˆ†ä¸»è¦æ˜¯ HTML ç»“æ„å’Œ CSS æ ·å¼ã€‚

æˆ‘ç°åœ¨å°†è¯»å–æ–‡ä»¶çš„ååŠéƒ¨åˆ†ï¼Œé€šå¸¸ JavaScript ä»£ç ä¼šæ”¾åœ¨ `<body>` æ ‡ç­¾çš„æœ«å°¾æˆ–è€… `<head>` ä¸­å¼•å…¥ã€‚


---

Read file: main/xiaozhi-server/test/test_page.html

---



---

å¥½çš„ï¼Œæˆ‘å·²ç»åˆ†æäº† `test_page.html` çš„ JavaScript ä»£ç ã€‚

é—®é¢˜åœ¨äºï¼š
1.  `websocket.onmessage` å‡½æ•°åœ¨å¤„ç†æ–‡æœ¬æ¶ˆæ¯æ—¶ï¼Œæ²¡æœ‰è¯†åˆ« `tts_mp3` è¿™ä¸ªç±»å‹ï¼Œå¯¼è‡´æ‰“å° "æœªçŸ¥æ¶ˆæ¯ç±»å‹"ã€‚
2.  `handleBinaryMessage` å‡½æ•°é»˜è®¤æ‰€æœ‰æ¥æ”¶åˆ°çš„äºŒè¿›åˆ¶æ•°æ®éƒ½æ˜¯ Opus æ ¼å¼ï¼Œå¹¶å°è¯•ç”¨ Opus è§£ç å™¨è§£ç ã€‚ä½†æ ¹æ®ä½ çš„æœåŠ¡å™¨æ—¥å¿—å’Œé—®é¢˜æè¿°ï¼ŒæœåŠ¡å™¨å®é™…å‘é€çš„æ˜¯ MP3 æ ¼å¼çš„ TTS éŸ³é¢‘ï¼Œå› æ­¤ Opus è§£ç å¤±è´¥ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹ JavaScript ä»£ç ï¼Œä½¿å…¶èƒ½å¤Ÿè¯†åˆ« `tts_mp3` æ¶ˆæ¯ï¼Œå¹¶æ ¹æ®é¢„æœŸçš„éŸ³é¢‘æ ¼å¼ï¼ˆOpus æˆ– MP3ï¼‰æ¥å¤„ç†æ¥æ”¶åˆ°çš„äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®ã€‚

**ä¿®æ”¹æ–¹æ¡ˆï¼š**
1.  å¢åŠ ä¸€ä¸ªå˜é‡ `expectedAudioFormat` æ¥è·Ÿè¸ªæœŸæœ›æ¥æ”¶çš„éŸ³é¢‘æ ¼å¼ï¼Œé»˜è®¤ä¸º `'opus'`ã€‚
2.  ä¿®æ”¹ `onmessage` å‡½æ•°ï¼š
    *   å½“æ”¶åˆ°æ˜ç¡®æŒ‡ç¤ºæ¥ä¸‹æ¥æ˜¯ MP3 éŸ³é¢‘çš„æ–‡æœ¬æ¶ˆæ¯æ—¶ï¼ˆæ¯”å¦‚ä¸€ä¸ª `{"type": "tts_start", "format": "mp3"}` æ¶ˆæ¯ï¼Œæˆ–è€…æˆ‘ä»¬å¯ä»¥æš‚æ—¶å°† `tts_mp3` æ–‡æœ¬æ¶ˆæ¯æœ¬èº«ä½œä¸ºä¿¡å·ï¼‰ï¼Œè®¾ç½® `expectedAudioFormat = 'mp3'`ã€‚
    *   å½“æ”¶åˆ°å…¶ä»–éœ€è¦ Opus éŸ³é¢‘çš„æ¶ˆæ¯ï¼ˆå¦‚ `reply` åï¼‰æˆ–éŸ³é¢‘æµç»“æŸæ—¶ï¼Œé‡ç½® `expectedAudioFormat = 'opus'`ã€‚
3.  ä¿®æ”¹ `handleBinaryMessage` å‡½æ•°ï¼š
    *   æ£€æŸ¥ `expectedAudioFormat` çš„å€¼ã€‚
    *   å¦‚æœæ˜¯ `'opus'`ï¼Œåˆ™æŒ‰ç°æœ‰é€»è¾‘å¤„ç†ï¼ˆæ¨å…¥ `audioBufferQueue`ï¼Œä½¿ç”¨ Opus è§£ç ï¼‰ã€‚
    *   å¦‚æœæ˜¯ `'mp3'`ï¼Œåˆ™å°†æ¥æ”¶åˆ°çš„äºŒè¿›åˆ¶æ•°æ®æ¨å…¥ä¸€ä¸ªæ–°çš„ç¼“å†²é˜Ÿåˆ— `mp3BufferQueue`ã€‚
4.  æ·»åŠ æ–°çš„å‡½æ•° `playBufferedMp3`ï¼š
    *   å½“ MP3 æ•°æ®ç¼“å†²è¶³å¤Ÿæˆ–æ¥æ”¶åˆ°ç»“æŸä¿¡å·æ—¶è°ƒç”¨æ­¤å‡½æ•°ã€‚
    *   å°† `mp3BufferQueue` ä¸­çš„æ‰€æœ‰ MP3 æ•°æ®å—åˆå¹¶æˆä¸€ä¸ª Blobã€‚
    *   åˆ›å»ºä¸€ä¸ª Blob URLã€‚
    *   ä½¿ç”¨ `<audio>` å…ƒç´ æˆ– `AudioContext` æ’­æ”¾è¿™ä¸ª MP3 Blob URLã€‚
    *   æ’­æ”¾ç»“æŸåæ¸…ç†èµ„æºå¹¶é‡ç½® `mp3BufferQueue` å’Œ `expectedAudioFormat`ã€‚
5.  è°ƒæ•´ `startAudioBuffering` å’Œå¤„ç†éŸ³é¢‘ç»“æŸçš„é€»è¾‘ï¼Œä»¥ä¾¿åœ¨ `expectedAudioFormat === 'mp3'` æ—¶è°ƒç”¨ `playBufferedMp3` è€Œä¸æ˜¯ `playBufferedAudio`ï¼ˆå¤„ç† Opus çš„å‡½æ•°ï¼‰ã€‚

æˆ‘ç°åœ¨å°†å¯¹ `main/xiaozhi-server/test/test_page.html` æ–‡ä»¶è¿›è¡Œä¿®æ”¹ã€‚


---



---



---

å—¯ï¼Œçœ‹èµ·æ¥åˆšæ‰çš„ä¿®æ”¹æ²¡æœ‰è¢«æ­£ç¡®åº”ç”¨ã€‚æˆ‘å°†å°è¯•é‡æ–°åº”ç”¨è¿™äº›æ›´æ”¹ã€‚


---

```diff
                  if (data instanceof ArrayBuffer) {
                      arrayBuffer = data;
-                     log(`æ”¶åˆ°ArrayBufferéŸ³é¢‘æ•°æ®ï¼Œå¤§å°: ${data.byteLength}å­—èŠ‚`, 'debug');
+                     // log(`æ”¶åˆ°ArrayBufferéŸ³é¢‘æ•°æ®ï¼Œå¤§å°: ${data.byteLength}å­—èŠ‚`, 'debug');
                  } else if (data instanceof Blob) {
-                     // å¦‚æœæ˜¯Blobç±»å‹ï¼Œè½¬æ¢ä¸ºArrayBuffer
                      arrayBuffer = await data.arrayBuffer();
-                     log(`æ”¶åˆ°BlobéŸ³é¢‘æ•°æ®ï¼Œå¤§å°: ${arrayBuffer.byteLength}å­—èŠ‚`, 'debug');
+                     // log(`æ”¶åˆ°BlobéŸ³é¢‘æ•°æ®ï¼Œå¤§å°: ${arrayBuffer.byteLength}å­—èŠ‚`, 'debug');
                  } else {
                      log(`æ”¶åˆ°æœªçŸ¥ç±»å‹çš„äºŒè¿›åˆ¶æ•°æ®: ${typeof data}`, 'warning');
                      return;
                  }
  
-                 // åˆ›å»ºUint8Arrayç”¨äºå¤„ç†
-                 const opusData = new Uint8Array(arrayBuffer);
+                 const binaryData = new Uint8Array(arrayBuffer);
+                 log(`æ”¶åˆ° ${expectedAudioFormat.toUpperCase()} éŸ³é¢‘æ•°æ®ï¼Œå¤§å°: ${binaryData.length}å­—èŠ‚`, 'debug');
  
-                 if (opusData.length > 0) {
-                     // å°†æ•°æ®æ·»åŠ åˆ°ç¼“å†²é˜Ÿåˆ—
-                     audioBufferQueue.push(opusData);
- 
-                     // å¦‚æœæ”¶åˆ°çš„æ˜¯ç¬¬ä¸€ä¸ªéŸ³é¢‘åŒ…ï¼Œå¼€å§‹ç¼“å†²è¿‡ç¨‹
-                     if (audioBufferQueue.length === 1 && !isAudioBuffering && !isAudioPlaying) {
-                         startAudioBuffering();
+                 if (binaryData.length > 0) {
+                     if (expectedAudioFormat === 'opus') {
+                         // Handle Opus data
+                         audioBufferQueue.push(binaryData);
+                         if (audioBufferQueue.length === 1 && !isAudioBuffering && !isAudioPlaying) {
+                             startAudioBuffering(); // Start buffering for Opus
+                         }
+                     } else if (expectedAudioFormat === 'mp3') {
+                         // Handle MP3 data
+                         mp3BufferQueue.push(binaryData);
+                         if (mp3BufferQueue.length === 1 && !isAudioBuffering && !isAudioPlaying) {
+                             startAudioBuffering(); // Start buffering for MP3
+                         }
                      }
                  } else {
-                     log('æ”¶åˆ°ç©ºéŸ³é¢‘æ•°æ®å¸§ï¼Œå¯èƒ½æ˜¯ç»“æŸæ ‡å¿—', 'warning');
+                     log(`æ”¶åˆ°ç©º ${expectedAudioFormat.toUpperCase()} æ•°æ®å¸§ï¼Œå¯èƒ½æ˜¯ç»“æŸæ ‡å¿—`, 'warning');
  
-                     // å¦‚æœç¼“å†²é˜Ÿåˆ—ä¸­æœ‰æ•°æ®ä¸”æ²¡æœ‰åœ¨æ’­æ”¾ï¼Œç«‹å³å¼€å§‹æ’­æ”¾
-                     if (audioBufferQueue.length > 0 && !isAudioPlaying) {
-                         playBufferedAudio();
-                     }
- 
-                     // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œå‘é€ç»“æŸä¿¡å·
-                     if (isAudioPlaying && streamingContext) {
-                         streamingContext.endOfStream = true;
-                     }
+                     if (expectedAudioFormat === 'opus') {
+                         // End of Opus stream
+                         if (audioBufferQueue.length > 0 && !isAudioPlaying) {
+                             playBufferedAudio(); // Play remaining Opus
+                         }
+                         if (isAudioPlaying && streamingContext) {
+                             streamingContext.endOfStream = true;
+                         }
+                     } else if (expectedAudioFormat === 'mp3') {
+                         // End of MP3 stream
+                         if (mp3BufferQueue.length > 0 && !isAudioPlaying) {
+                              playBufferedMp3(); // Play buffered MP3
+                         }
+                         // No specific end-of-stream needed for blob playback? Or handled in playBufferedMp3
+                     }
+                     // Reset format after stream ends? Maybe do this in playback functions.
+                     // expectedAudioFormat = 'opus';
                  }
              } catch (error) {
          }
  
-         // è·å–é…ç½®å€¼
-         function getConfig() {
-             const deviceMac = document.getElementById('deviceMac').value.trim();
-             return {
-                 deviceId: deviceMac,  // ä½¿ç”¨MACåœ°å€ä½œä¸ºdeviceId
-                 deviceName: document.getElementById('deviceName').value.trim(),
-                 deviceMac: deviceMac,
-                 clientId: document.getElementById('clientId').value.trim(),
-                 token: document.getElementById('token').value.trim()
-             };
+         // ... existing code ...
+ 
+         function startAudioBuffering() {
+             if (isAudioBuffering || isAudioPlaying) return;
+ 
+             isAudioBuffering = true;
+             log('å¼€å§‹éŸ³é¢‘ç¼“å†²...', 'info');
+ 
+             clearTimeout(bufferingTimer); // Clear any previous timer
+             bufferingTimer = setTimeout(() => {
+                 log(`ç¼“å†²è¶…æ—¶ï¼Œå½“å‰ç¼“å†²åŒ…æ•°: ${expectedAudioFormat === 'mp3' ? mp3BufferQueue.length : audioBufferQueue.length}ï¼Œå¼€å§‹æ’­æ”¾`, 'warning');
+                 isAudioBuffering = false;
+                 if (expectedAudioFormat === 'mp3') {
+                     playBufferedMp3();
+                 } else {
+                     playBufferedAudio(); // Play whatever Opus we have
+                 }
+             }, BUFFERING_TIMEOUT);
+         }
+ 
+         function playBufferedAudio() { // Renamed slightly implicitly to clarify it's for Opus
+             if (isAudioPlaying || audioBufferQueue.length === 0) {
+                 clearTimeout(bufferingTimer); // Stop buffering timer if playback starts
+                 isAudioBuffering = false;
+                 return;
+             }
+ 
+             clearTimeout(bufferingTimer); // Stop buffering timer
+             isAudioBuffering = false;
+             isAudioPlaying = true;
+             streamingContext.endOfStream = false; // Reset end of stream flag
+             log(`å¼€å§‹æ’­æ”¾ç¼“å†²çš„ Opus éŸ³é¢‘ (${audioBufferQueue.length} åŒ…)`, 'info');
+ 
+             if (!audioContext) {
+                 audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
+             }
+             if (!opusDecoder) {
+                 log('Opusè§£ç å™¨æœªåˆå§‹åŒ–', 'error');
+                 isAudioPlaying = false;
+                 expectedAudioFormat = 'opus'; // Reset format on error
+                 return;
+             }
+ 
+             let sourceNode = audioContext.createBufferSource();
+             streamingContext.sourceNode = sourceNode;
+             streamingContext.startTime = audioContext.currentTime;
+             streamingContext.processedDuration = 0;
+ 
+             const processQueue = () => {
+                 if (audioBufferQueue.length === 0 && !streamingContext.endOfStream) {
+                     // Buffer ran out, wait for more data or end signal
+                     setTimeout(processQueue, 50); // Check again shortly
+                     return;
+                 }
+ 
+                 if (audioBufferQueue.length > 0) {
+                     const opusPacket = audioBufferQueue.shift();
+                     try {
+                         const decodedPcm = opusDecoder.decode(opusPacket); // Decode Int16 PCM
+                         if (decodedPcm && decodedPcm.length > 0) {
+                             // Convert Int16 PCM to Float32 for Web Audio API
+                             const float32Pcm = new Float32Array(decodedPcm.length);
+                             for (let i = 0; i < decodedPcm.length; i++) {
+                                 float32Pcm[i] = decodedPcm[i] / 32768.0;
+                             }
+ 
+                             const audioBuffer = audioContext.createBuffer(1, float32Pcm.length, sampleRate);
+                             audioBuffer.copyToChannel(float32Pcm, 0);
+ 
+                             sourceNode = audioContext.createBufferSource();
+                             sourceNode.buffer = audioBuffer;
+                             sourceNode.connect(audioContext.destination);
+ 
+                             const offset = streamingContext.processedDuration;
+                             const startAt = streamingContext.startTime + offset;
+ 
+                             sourceNode.start(startAt);
+                             streamingContext.processedDuration += audioBuffer.duration;
+ 
+                             // Schedule the next chunk
+                             sourceNode.onended = () => {
+                                 if (!streamingContext.endOfStream || audioBufferQueue.length > 0) {
+                                     processQueue();
+                                 } else {
+                                     log('Opus éŸ³é¢‘æ’­æ”¾ç»“æŸ', 'info');
+                                     isAudioPlaying = false;
+                                     expectedAudioFormat = 'opus'; // Reset format
+                                 }
+                             };
+                         } else {
+                             log('Opusè§£ç äº§ç”Ÿç©ºæ•°æ®', 'warning');
+                             // If decoding fails or gives empty data, continue processing queue
+                             if (!streamingContext.endOfStream || audioBufferQueue.length > 0) {
+                                 processQueue();
+                              } else {
+                                 log('Opus éŸ³é¢‘æ’­æ”¾ç»“æŸ (è§£ç ç©ºæ•°æ®)', 'info');
+                                 isAudioPlaying = false;
+                                 expectedAudioFormat = 'opus'; // Reset format
+                             }
+                         }
+                     } catch (error) {
+                         log(`Opusè§£ç é”™è¯¯: ${error.message}`, 'error');
+                         // Skip this packet and try the next one
+                         if (!streamingContext.endOfStream || audioBufferQueue.length > 0) {
+                              processQueue();
+                         } else {
+                            log('Opus éŸ³é¢‘æ’­æ”¾ç»“æŸ (è§£ç é”™è¯¯)', 'info');
+                            isAudioPlaying = false;
+                            expectedAudioFormat = 'opus'; // Reset format
+                         }
+                     }
+                 } else if (streamingContext.endOfStream) {
+                     // End of stream and queue is empty
+                     log('Opus éŸ³é¢‘æµç»“æŸï¼Œé˜Ÿåˆ—å·²ç©º', 'info');
+                     isAudioPlaying = false;
+                     expectedAudioFormat = 'opus'; // Reset format
+                 }
+             };
+ 
+             processQueue();
          }
  
-         // éªŒè¯é…ç½®
-         function validateConfig(config) {
-             if (!config.deviceMac) {
-                 log('è®¾å¤‡MACåœ°å€ä¸èƒ½ä¸ºç©º', 'error');
-                 return false;
-             }
-             if (!config.clientId) {
-                 log('å®¢æˆ·ç«¯IDä¸èƒ½ä¸ºç©º', 'error');
-                 return false;
-             }
-             return true;
-         }
- 
-         initApp();
-     </script>
- </body>
- 
- </html>
+         // New function to play buffered MP3 data
+         function playBufferedMp3() {
+             if (isAudioPlaying || mp3BufferQueue.length === 0) {
+                 clearTimeout(bufferingTimer); // Stop buffering timer if playback starts
+                 isAudioBuffering = false;
+                 return;
+             }
+ 
+             clearTimeout(bufferingTimer); // Stop buffering timer
+             isAudioBuffering = false;
+             isAudioPlaying = true;
+             log(`å¼€å§‹æ’­æ”¾ç¼“å†²çš„ MP3 éŸ³é¢‘ (${mp3BufferQueue.length} åŒ…)`, 'info');
+ 
+             try {
+                 // Concatenate all MP3 chunks into a single Blob
+                 const mp3Blob = new Blob(mp3BufferQueue, { type: 'audio/mpeg' });
+                 const mp3Url = URL.createObjectURL(mp3Blob);
+ 
+                 // Use an <audio> element for playback
+                 if (!audioPlaybackElement) {
+                     audioPlaybackElement = new Audio();
+                     audioPlaybackElement.addEventListener('ended', () => {
+                         log('MP3 éŸ³é¢‘æ’­æ”¾ç»“æŸ', 'info');
+                         URL.revokeObjectURL(mp3Url); // Clean up Blob URL
+                         isAudioPlaying = false;
+                         mp3BufferQueue = []; // Clear buffer after playing
+                         expectedAudioFormat = 'opus'; // Reset format after MP3 playback
+                         audioPlaybackElement = null; // Remove element or reuse
+                     });
+                     audioPlaybackElement.addEventListener('error', (e) => {
+                         log(`MP3 æ’­æ”¾é”™è¯¯: ${e.target.error.message}`, 'error');
+                         URL.revokeObjectURL(mp3Url); // Clean up Blob URL
+                         isAudioPlaying = false;
+                         mp3BufferQueue = [];
+                         expectedAudioFormat = 'opus';
+                         audioPlaybackElement = null;
+                     });
+                 }
+ 
+                 audioPlaybackElement.src = mp3Url;
+                 audioPlaybackElement.play();
+ 
+             } catch (error) {
+                 log(`åˆ›å»ºæˆ–æ’­æ”¾ MP3 Blob æ—¶å‡ºé”™: ${error.message}`, 'error');
+                 isAudioPlaying = false;
+                 mp3BufferQueue = []; // Clear buffer on error
+                 expectedAudioFormat = 'opus'; // Reset format
+             }
+         }
+ 
+ 
+         // ... existing code ...
```

---

_**User**_

ä¸ºä»€ä¹ˆä¿®æ”¹åï¼Œéƒ½æ— æ³•è¿æ¥wsäº†ï¼Ÿ

---

_**Assistant**_



---

æŠ±æ­‰ï¼Œä¿®æ”¹åçš„ä»£ç å¯¼è‡´æ— æ³•è¿æ¥ WebSocketï¼Œå¾ˆå¯èƒ½æ˜¯å› ä¸ºæˆ‘åœ¨ä¸Šä¸€æ¬¡ä¿®æ”¹ä¸­å¼•å…¥äº†ä¸€äº›æ–°çš„å…¨å±€å˜é‡ï¼ˆç”¨äºå¤„ç† MP3 éŸ³é¢‘ï¼‰ï¼Œä½†åœ¨é‡æ–°åº”ç”¨ç¼–è¾‘æ—¶ï¼Œè¿™äº›å˜é‡çš„å£°æ˜å¯èƒ½æ²¡æœ‰è¢«æ­£ç¡®æ·»åŠ ï¼Œå¯¼è‡´åç»­ä»£ç å¼•ç”¨è¿™äº›æœªå£°æ˜çš„å˜é‡æ—¶å‡ºé”™ï¼Œä»è€Œä¸­æ–­äº†è„šæœ¬çš„æ‰§è¡Œï¼Œä½¿å¾—è¿æ¥åŠŸèƒ½æ— æ³•æ­£å¸¸è¿è¡Œã€‚

å¿…éœ€çš„å…¨å±€å˜é‡åŒ…æ‹¬ `mp3BufferQueue`, `expectedAudioFormat`, `audioPlaybackElement`, `BUFFERING_TIMEOUT`, `MIN_BUFFER_PACKETS`, å’Œ `bufferingTimer`ã€‚

æˆ‘ç°åœ¨å°†é‡æ–°ç¼–è¾‘ `test_page.html` æ–‡ä»¶ï¼Œç¡®ä¿è¿™äº›å…¨å±€å˜é‡è¢«æ­£ç¡®å£°æ˜åœ¨è„šæœ¬çš„å¼€å¤´éƒ¨åˆ†ã€‚


---

```diff
          let visualizerCanvas = document.getElementById('audioVisualizer');
          let visualizerContext = visualizerCanvas.getContext('2d');
-         let audioQueue = [];
-         let isPlaying = false;
          let opusDecoder = null; // Opusè§£ç å™¨
+         let opusEncoder = null; // Opusç¼–ç å™¨ (from later code)
          let visualizationRequest = null; // åŠ¨ç”»å¸§è¯·æ±‚ID
  
-         // éŸ³é¢‘æµç¼“å†²ç›¸å…³
-         let audioBuffers = []; // ç”¨äºå­˜å‚¨æ¥æ”¶åˆ°çš„æ‰€æœ‰éŸ³é¢‘æ•°æ®
-         let totalAudioSize = 0; // è·Ÿè¸ªç´¯ç§¯çš„éŸ³é¢‘å¤§å°
- 
-         let audioBufferQueue = [];     // å­˜å‚¨æ¥æ”¶åˆ°çš„éŸ³é¢‘åŒ…
+         // éŸ³é¢‘æµç¼“å†²ç›¸å…³ (Opus + MP3)
+         let audioBufferQueue = [];     // å­˜å‚¨æ¥æ”¶åˆ°çš„ Opus éŸ³é¢‘åŒ…
+         let mp3BufferQueue = [];       // æ–°å¢ï¼šå­˜å‚¨æ¥æ”¶åˆ°çš„ MP3 éŸ³é¢‘åŒ…
          let isAudioBuffering = false;  // æ˜¯å¦æ­£åœ¨ç¼“å†²éŸ³é¢‘
-         let isAudioPlaying = false;    // æ˜¯å¦æ­£åœ¨æ’­æ”¾éŸ³é¢‘
-         const BUFFER_THRESHOLD = 3;    // ç¼“å†²åŒ…æ•°é‡é˜ˆå€¼ï¼Œè‡³å°‘ç´¯ç§¯3ä¸ªåŒ…å†å¼€å§‹æ’­æ”¾
+         let isAudioPlaying = false;    // æ˜¯å¦æ­£åœ¨æ’­æ”¾éŸ³é¢‘ (replaces old isPlaying)
+         let expectedAudioFormat = 'opus'; // æ–°å¢ï¼šæœŸæœ›çš„éŸ³é¢‘æ ¼å¼ ('opus' or 'mp3')
+         let audioPlaybackElement = null; // æ–°å¢ï¼šç”¨äºæ’­æ”¾ MP3 çš„ <audio> å…ƒç´ 
+         let bufferingTimer = null;       // æ–°å¢ï¼šç¼“å†²è¶…æ—¶è®¡æ—¶å™¨
+         const BUFFERING_TIMEOUT = 1000;  // æ–°å¢ï¼šç¼“å†²è¶…æ—¶æ—¶é—´ (ms)
+         const MIN_BUFFER_PACKETS = 1; // æ–°å¢ï¼šå¼€å§‹æ’­æ”¾çš„æœ€å°åŒ…æ•°
          const MIN_AUDIO_DURATION = 0.1; // æœ€å°éŸ³é¢‘é•¿åº¦(ç§’)ï¼Œå°äºè¿™ä¸ªé•¿åº¦çš„éŸ³é¢‘ä¼šè¢«åˆå¹¶
-         let streamingContext = null;   // éŸ³é¢‘æµä¸Šä¸‹æ–‡
+         let streamingContext = { // Modified slightly for Opus playback
+             sourceNode: null,
+             startTime: 0,
+             processedDuration: 0,
+             endOfStream: false
+         };
          const SAMPLE_RATE = 16000;     // é‡‡æ ·ç‡
          const CHANNELS = 1;            // å£°é“æ•°
-         const FRAME_SIZE = 960;        // å¸§å¤§å°
+         const opusFrameSize = 960; // 60ms @ 16kHz for encoding
+ 
+         // PCM Recording related (from later code)
+         let audioProcessor = null;
+         let audioProcessorType = null;
+         let audioSource = null;
+         let pcmDataBuffer = new Int16Array();
  
          // DOMå…ƒç´ 
              conversationDiv.scrollTop = conversationDiv.scrollHeight;
          }
- 
  
          // å¼€å§‹éŸ³é¢‘ç¼“å†²è¿‡ç¨‹
              log("å¼€å§‹éŸ³é¢‘ç¼“å†²...", 'info');
  
-             // å…ˆå°è¯•åˆå§‹åŒ–è§£ç å™¨ï¼Œä»¥ä¾¿åœ¨æ’­æ”¾æ—¶å·²å‡†å¤‡å¥½
-             initOpusDecoder().catch(error => {
-                 log(`é¢„åˆå§‹åŒ–Opusè§£ç å™¨å¤±è´¥: ${error.message}`, 'warning');
-                 // ç»§ç»­ç¼“å†²ï¼Œæˆ‘ä»¬ä¼šåœ¨æ’­æ”¾æ—¶å†æ¬¡å°è¯•åˆå§‹åŒ–
-             });
- 
-             // è®¾ç½®è¶…æ—¶ï¼Œå¦‚æœåœ¨ä¸€å®šæ—¶é—´å†…æ²¡æœ‰æ”¶é›†åˆ°è¶³å¤Ÿçš„éŸ³é¢‘åŒ…ï¼Œå°±å¼€å§‹æ’­æ”¾
-             setTimeout(() => {
-                 if (isAudioBuffering && audioBufferQueue.length > 0) {
-                     log(`ç¼“å†²è¶…æ—¶ï¼Œå½“å‰ç¼“å†²åŒ…æ•°: ${audioBufferQueue.length}ï¼Œå¼€å§‹æ’­æ”¾`, 'info');
-                     playBufferedAudio();
+             clearTimeout(bufferingTimer); // Clear any previous timer
+             bufferingTimer = setTimeout(() => {
+                 log(`ç¼“å†²è¶…æ—¶ï¼Œå½“å‰ç¼“å†²åŒ…æ•°: ${expectedAudioFormat === 'mp3' ? mp3BufferQueue.length : audioBufferQueue.length}ï¼Œå¼€å§‹æ’­æ”¾`, 'warning');
+                 isAudioBuffering = false;
+                 if (expectedAudioFormat === 'mp3') {
+                     playBufferedMp3();
+                 } else {
+                     playBufferedAudio(); // Play whatever Opus we have
                  }
-             }, 300); // 300msè¶…æ—¶
- 
-             // ç›‘æ§ç¼“å†²è¿›åº¦
-             const bufferCheckInterval = setInterval(() => {
-                 if (!isAudioBuffering) {
-                     clearInterval(bufferCheckInterval);
+             }, BUFFERING_TIMEOUT);
+         }
+ 
+         // æ’­æ”¾å·²ç¼“å†²çš„éŸ³é¢‘
+         function playBufferedAudio() { // Renamed slightly implicitly to clarify it's for Opus
+             if (isAudioPlaying || audioBufferQueue.length === 0) {
+                 clearTimeout(bufferingTimer); // Stop buffering timer if playback starts
+                 isAudioBuffering = false;
                  return;
              }
  
-                 // å½“ç´¯ç§¯äº†è¶³å¤Ÿçš„éŸ³é¢‘åŒ…ï¼Œå¼€å§‹æ’­æ”¾
-                 if (audioBufferQueue.length >= BUFFER_THRESHOLD) {
-                     clearInterval(bufferCheckInterval);
-                     log(`å·²ç¼“å†² ${audioBufferQueue.length} ä¸ªéŸ³é¢‘åŒ…ï¼Œå¼€å§‹æ’­æ”¾`, 'info');
-                     playBufferedAudio();
-                 }
-             }, 50);
-         }
- 
-         // æ’­æ”¾å·²ç¼“å†²çš„éŸ³é¢‘
-         function playBufferedAudio() {
-             if (isAudioPlaying || audioBufferQueue.length === 0) return;
- 
-             isAudioPlaying = true;
+             clearTimeout(bufferingTimer); // Stop buffering timer
              isAudioBuffering = false;
+             isAudioPlaying = true;
+             streamingContext.endOfStream = false; // Reset end of stream flag
+             log(`å¼€å§‹æ’­æ”¾ç¼“å†²çš„ Opus éŸ³é¢‘ (${audioBufferQueue.length} åŒ…)`, 'info');
  
-             // ç¡®ä¿Opusè§£ç å™¨å·²åˆå§‹åŒ–
-             const initDecoderAndPlay = async () => {
-                 try {
-                     // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å­˜åœ¨
              if (!audioContext) {
-                         audioContext = new (window.AudioContext || window.webkitAudioContext)({
-                             sampleRate: SAMPLE_RATE
-                         });
-                         log('åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡ï¼Œé‡‡æ ·ç‡: ' + SAMPLE_RATE + 'Hz', 'debug');
+                 audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
              }
- 
-                     // ç¡®ä¿è§£ç å™¨å·²åˆå§‹åŒ–
              if (!opusDecoder) {
-                         log('åˆå§‹åŒ–Opusè§£ç å™¨...', 'info');
-                         try {
-                             opusDecoder = await initOpusDecoder();
-                             if (!opusDecoder) {
-                                 throw new Error('è§£ç å™¨åˆå§‹åŒ–å¤±è´¥');
-                             }
-                             log('Opusè§£ç å™¨åˆå§‹åŒ–æˆåŠŸ', 'success');
-                         } catch (error) {
-                             log('Opusè§£ç å™¨åˆå§‹åŒ–å¤±è´¥: ' + error.message, 'error');
+                 log('Opusè§£ç å™¨æœªåˆå§‹åŒ–', 'error');
                  isAudioPlaying = false;
+                 expectedAudioFormat = 'opus'; // Reset format on error
                  return;
              }
-                     }
- 
-                     // åˆ›å»ºæµå¼æ’­æ”¾ä¸Šä¸‹æ–‡
-                     if (!streamingContext) {
-                         streamingContext = {
-                             queue: [],          // å·²è§£ç çš„PCMé˜Ÿåˆ—
-                             playing: false,     // æ˜¯å¦æ­£åœ¨æ’­æ”¾
-                             endOfStream: false, // æ˜¯å¦æ”¶åˆ°ç»“æŸä¿¡å·
-                             source: null,       // å½“å‰éŸ³é¢‘æº
-                             totalSamples: 0,    // ç´¯ç§¯çš„æ€»æ ·æœ¬æ•°
-                             lastPlayTime: 0,    // ä¸Šæ¬¡æ’­æ”¾çš„æ—¶é—´æˆ³
- 
-                             // å°†Opusæ•°æ®è§£ç ä¸ºPCM
-                             decodeOpusFrames: async function (opusFrames) {
-                                 if (!opusDecoder) {
-                                     log('Opusè§£ç å™¨æœªåˆå§‹åŒ–ï¼Œæ— æ³•è§£ç ', 'error');
+ 
+             let sourceNode = audioContext.createBufferSource();
+             streamingContext.sourceNode = sourceNode;
+             streamingContext.startTime = audioContext.currentTime;
+             streamingContext.processedDuration = 0;
+ 
+             const processQueue = () => {
+                 if (audioBufferQueue.length === 0 && !streamingContext.endOfStream) {
+                     // Buffer ran out, wait for more data or end signal
+                     setTimeout(processQueue, 50); // Check again shortly
                      return;
                  }
  
-                                 let decodedSamples = [];
- 
-                                 for (const frame of opusFrames) {
-                                     try {
-                                         // ä½¿ç”¨Opusè§£ç å™¨è§£ç 
-                                         const frameData = opusDecoder.decode(frame);
-                                         if (frameData && frameData.length > 0) {
-                                             // è½¬æ¢ä¸ºFloat32
-                                             const floatData = convertInt16ToFloat32(frameData);
-                                             decodedSamples.push(...floatData);
-                                         }
-                                     } catch (error) {
-                                         log("Opusè§£ç å¤±è´¥: " + error.message, 'error');
-                                     }
-                                 }
- 
-                                 if (decodedSamples.length > 0) {
-                                     // æ·»åŠ åˆ°è§£ç é˜Ÿåˆ—
-                                     this.queue.push(...decodedSamples);
-                                     this.totalSamples += decodedSamples.length;
- 
-                                     // å¦‚æœç´¯ç§¯äº†è‡³å°‘0.2ç§’çš„éŸ³é¢‘ï¼Œå¼€å§‹æ’­æ”¾
-                                     const minSamples = SAMPLE_RATE * MIN_AUDIO_DURATION;
-                                     if (!this.playing && this.queue.length >= minSamples) {
-                                         this.startPlaying();
-                                     }
-                                 } else {
-                                     log('æ²¡æœ‰æˆåŠŸè§£ç çš„æ ·æœ¬', 'warning');
-                                 }
-                             },
- 
-                             // å¼€å§‹æ’­æ”¾éŸ³é¢‘
-                             startPlaying: function () {
-                                 if (this.playing || this.queue.length === 0) return;
- 
-                                 this.playing = true;
- 
-                                 // åˆ›å»ºæ–°çš„éŸ³é¢‘ç¼“å†²åŒº
-                                 const minPlaySamples = Math.min(this.queue.length, SAMPLE_RATE); // æœ€å¤šæ’­æ”¾1ç§’
-                                 const currentSamples = this.queue.splice(0, minPlaySamples);
+                 if (audioBufferQueue.length > 0) {
+                     const opusPacket = audioBufferQueue.shift();
+                     try {
+                         const decodedPcm = opusDecoder.decode(opusPacket); // Decode Int16 PCM
+                         if (decodedPcm && decodedPcm.length > 0) {
+                             // Convert Int16 PCM to Float32 for Web Audio API
+                             const float32Pcm = new Float32Array(decodedPcm.length);
+                             for (let i = 0; i < decodedPcm.length; i++) {
+                                 float32Pcm[i] = decodedPcm[i] / 32768.0;
+                             }
  
-                                 const audioBuffer = audioContext.createBuffer(CHANNELS, currentSamples.length, SAMPLE_RATE);
-                                 audioBuffer.copyToChannel(new Float32Array(currentSamples), 0);
+                             const audioBuffer = audioContext.createBuffer(1, float32Pcm.length, sampleRate);
+                             audioBuffer.copyToChannel(float32Pcm, 0);
  
-                                 // åˆ›å»ºéŸ³é¢‘æº
-                                 this.source = audioContext.createBufferSource();
-                                 this.source.buffer = audioBuffer;
- 
-                                 // åˆ›å»ºå¢ç›ŠèŠ‚ç‚¹ç”¨äºå¹³æ»‘è¿‡æ¸¡
-                                 const gainNode = audioContext.createGain();
- 
-                                 // åº”ç”¨æ·¡å…¥æ·¡å‡ºæ•ˆæœé¿å…çˆ†éŸ³
-                                 const fadeDuration = 0.02; // 20æ¯«ç§’
-                                 gainNode.gain.setValueAtTime(0, audioContext.currentTime);
-                                 gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + fadeDuration);
- 
-                                 const duration = audioBuffer.duration;
-                                 if (duration > fadeDuration * 2) {
-                                     gainNode.gain.setValueAtTime(1, audioContext.currentTime + duration - fadeDuration);
-                                     gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
-                                 }
- 
-                                 // è¿æ¥èŠ‚ç‚¹å¹¶å¼€å§‹æ’­æ”¾
-                                 this.source.connect(gainNode);
-                                 gainNode.connect(audioContext.destination);
- 
-                                 this.lastPlayTime = audioContext.currentTime;
-                                 log(`å¼€å§‹æ’­æ”¾ ${currentSamples.length} ä¸ªæ ·æœ¬ï¼Œçº¦ ${(currentSamples.length / SAMPLE_RATE).toFixed(2)} ç§’`, 'info');
- 
-                                 // æ’­æ”¾ç»“æŸåçš„å¤„ç†
-                                 this.source.onended = () => {
-                                     this.source = null;
-                                     this.playing = false;
- 
-                                     // å¦‚æœé˜Ÿåˆ—ä¸­è¿˜æœ‰æ•°æ®æˆ–è€…ç¼“å†²åŒºæœ‰æ–°æ•°æ®ï¼Œç»§ç»­æ’­æ”¾
-                                     if (this.queue.length > 0) {
-                                         setTimeout(() => this.startPlaying(), 10);
-                                     } else if (audioBufferQueue.length > 0) {
-                                         // ç¼“å†²åŒºæœ‰æ–°æ•°æ®ï¼Œè¿›è¡Œè§£ç 
-                                         const frames = [...audioBufferQueue];
-                                         audioBufferQueue = [];
-                                         this.decodeOpusFrames(frames);
-                                     } else if (this.endOfStream) {
-                                         // æµå·²ç»“æŸä¸”æ²¡æœ‰æ›´å¤šæ•°æ®
-                                         log("éŸ³é¢‘æ’­æ”¾å®Œæˆ", 'info');
+                             sourceNode = audioContext.createBufferSource();
+                             sourceNode.buffer = audioBuffer;
+                             sourceNode.connect(audioContext.destination);
+ 
+                             const offset = streamingContext.processedDuration;
+                             const startAt = streamingContext.startTime + offset;
+ 
+                             sourceNode.start(startAt);
+                             streamingContext.processedDuration += audioBuffer.duration;
+ 
+                             // Schedule the next chunk
+                             sourceNode.onended = () => {
+                                 if (!streamingContext.endOfStream || audioBufferQueue.length > 0) {
+                                     processQueue();
+                                 } else {
+                                     log('Opus éŸ³é¢‘æ’­æ”¾ç»“æŸ', 'info');
+                                     isAudioPlaying = false;
+                                     expectedAudioFormat = 'opus'; // Reset format
+                                 }
+                             };
+                         } else {
+                             log('Opusè§£ç äº§ç”Ÿç©ºæ•°æ®', 'warning');
+                             // If decoding fails or gives empty data, continue processing queue
+                             if (!streamingContext.endOfStream || audioBufferQueue.length > 0) {
+                                 processQueue();
+                             } else {
+                                 log('Opus éŸ³é¢‘æ’­æ”¾ç»“æŸ (è§£ç ç©ºæ•°æ®)', 'info');
                                  isAudioPlaying = false;
-                                         streamingContext = null;
+                                 expectedAudioFormat = 'opus'; // Reset format
+                             }
+                         }
+                     } catch (error) {
+                         log(`Opusè§£ç é”™è¯¯: ${error.message}`, 'error');
+                         // Skip this packet and try the next one
+                         if (!streamingContext.endOfStream || audioBufferQueue.length > 0) {
+                             processQueue();
                          } else {
-                                         // ç­‰å¾…æ›´å¤šæ•°æ®
-                                         setTimeout(() => {
-                                             // å¦‚æœä»ç„¶æ²¡æœ‰æ–°æ•°æ®ï¼Œä½†æœ‰æ›´å¤šçš„åŒ…åˆ°è¾¾
-                                             if (this.queue.length === 0 && audioBufferQueue.length > 0) {
-                                                 const frames = [...audioBufferQueue];
-                                                 audioBufferQueue = [];
-                                                 this.decodeOpusFrames(frames);
-                                             } else if (this.queue.length === 0 && audioBufferQueue.length === 0) {
-                                                 // çœŸçš„æ²¡æœ‰æ›´å¤šæ•°æ®äº†
-                                                 log("éŸ³é¢‘æ’­æ”¾å®Œæˆ (è¶…æ—¶)", 'info');
+                             log('Opus éŸ³é¢‘æ’­æ”¾ç»“æŸ (è§£ç é”™è¯¯)', 'info');
                              isAudioPlaying = false;
-                                                 streamingContext = null;
-                                             }
-                                         }, 500); // 500msè¶…æ—¶
+                             expectedAudioFormat = 'opus'; // Reset format
+                         }
+                     }
+                 } else if (streamingContext.endOfStream) {
+                     // End of stream and queue is empty
+                     log('Opus éŸ³é¢‘æµç»“æŸï¼Œé˜Ÿåˆ—å·²ç©º', 'info');
+                     isAudioPlaying = false;
+                     expectedAudioFormat = 'opus'; // Reset format
                  }
              };
  
-                                 this.source.start();
-                             }
-                         };
+             processQueue();
          }
  
-                     // å¼€å§‹å¤„ç†ç¼“å†²çš„æ•°æ®
-                     const frames = [...audioBufferQueue];
-                     audioBufferQueue = []; // æ¸…ç©ºç¼“å†²é˜Ÿåˆ—
- 
-                     // è§£ç å¹¶æ’­æ”¾
-                     await streamingContext.decodeOpusFrames(frames);
- 
-                 } catch (error) {
-                     log(`æ’­æ”¾å·²ç¼“å†²çš„éŸ³é¢‘å‡ºé”™: ${error.message}`, 'error');
+         // New function to play buffered MP3 data
+         function playBufferedMp3() {
+             if (isAudioPlaying || mp3BufferQueue.length === 0) {
+                 clearTimeout(bufferingTimer); // Stop buffering timer if playback starts
+                 isAudioBuffering = false;
+                 return;
+             }
+ 
+             clearTimeout(bufferingTimer); // Stop buffering timer
+             isAudioBuffering = false;
+             isAudioPlaying = true;
+             log(`å¼€å§‹æ’­æ”¾ç¼“å†²çš„ MP3 éŸ³é¢‘ (${mp3BufferQueue.length} åŒ…)`, 'info');
+ 
+             try {
+                 // Concatenate all MP3 chunks into a single Blob
+                 const mp3Blob = new Blob(mp3BufferQueue, { type: 'audio/mpeg' });
+                 const mp3Url = URL.createObjectURL(mp3Blob);
+ 
+                 // Use an <audio> element for playback
+                 if (!audioPlaybackElement) {
+                     audioPlaybackElement = new Audio();
+                     audioPlaybackElement.addEventListener('ended', () => {
+                         log('MP3 éŸ³é¢‘æ’­æ”¾ç»“æŸ', 'info');
+                         URL.revokeObjectURL(mp3Url); // Clean up Blob URL
                          isAudioPlaying = false;
-                     streamingContext = null;
-                 }
-             };
- 
-             // æ‰§è¡Œåˆå§‹åŒ–å’Œæ’­æ”¾
-             initDecoderAndPlay();
+                         mp3BufferQueue = []; // Clear buffer after playing
+                         expectedAudioFormat = 'opus'; // Reset format after MP3 playback
+                         audioPlaybackElement = null; // Remove element or reuse
+                     });
+                     audioPlaybackElement.addEventListener('error', (e) => {
+                         log(`MP3 æ’­æ”¾é”™è¯¯: ${e.target.error.message}`, 'error');
+                         URL.revokeObjectURL(mp3Url); // Clean up Blob URL
+                         isAudioPlaying = false;
+                         mp3BufferQueue = [];
+                         expectedAudioFormat = 'opus';
+                         audioPlaybackElement = null;
+                     });
+                 }
+ 
+                 audioPlaybackElement.src = mp3Url;
+                 audioPlaybackElement.play();
+ 
+             } catch (error) {
+                 log(`åˆ›å»ºæˆ–æ’­æ”¾ MP3 Blob æ—¶å‡ºé”™: ${error.message}`, 'error');
+                 isAudioPlaying = false;
+                 mp3BufferQueue = []; // Clear buffer on error
+                 expectedAudioFormat = 'opus'; // Reset format
+             }
          }
  
                      channels: CHANNELS,
                      rate: SAMPLE_RATE,
-                     frameSize: FRAME_SIZE,
+                     frameSize: opusFrameSize,
                      module: mod,
                      decoderPtr: null, // åˆå§‹ä¸ºnull
  
          // ä½¿ç”¨libopusåˆ›å»ºä¸€ä¸ªOpusç¼–ç å™¨
-         let opusEncoder = null;
          function initOpusEncoder() {
              try {
                      channels: channels,
                      sampleRate: sampleRate,
-                     frameSize: 960, // 60ms @ 16kHz = 60 * 16 = 960 samples
+                     frameSize: opusFrameSize, // 60ms @ 16kHz = 60 * 16 = 960 samples
                      maxPacketSize: 4000, // æœ€å¤§åŒ…å¤§å°
                      module: mod,
                      if (opusData && opusData.length > 0) {
                          // å­˜å‚¨éŸ³é¢‘å¸§
-                         audioBuffers.push(opusData.buffer);
+                         audioBufferQueue.push(opusData.buffer);
                          totalAudioSize += opusData.length;
  
```

---

çœ‹èµ·æ¥æˆ‘ä¹‹å‰æ·»åŠ å…¨å±€å˜é‡æ—¶ï¼Œä¸å°å¿ƒä¸æ–‡ä»¶åé¢éƒ¨åˆ†å·²ç»å­˜åœ¨çš„åŒåå˜é‡å£°æ˜ï¼ˆ`audioProcessor`, `audioProcessorType`, `audioSource`, `pcmDataBuffer`ï¼‰å†²çªäº†ã€‚

æˆ‘å°†ç§»é™¤è¿™äº›é‡å¤çš„å£°æ˜ï¼Œåªä¿ç•™æ–‡ä»¶å¼€å¤´éƒ¨åˆ†çš„å£°æ˜ã€‚
æ–‡ä»¶é¡¶éƒ¨ï¼ˆå…¨å±€ä½œç”¨åŸŸï¼‰çš„å£°æ˜ã€‚
åŸŸï¼‰çš„å£°æ˜ã€‚


---

```diff
  
          // åˆå§‹åŒ–ç›´æ¥ä»PCMæ•°æ®å½•éŸ³çš„ç³»ç»Ÿ
-         let audioProcessor = null;
-         let audioProcessorType = null;
-         let audioSource = null;
+         // let audioProcessor = null; // Keep global declaration
+         // let audioProcessorType = null; // Keep global declaration
+         // let audioSource = null; // Keep global declaration
  
          // å¤„ç†PCMç¼“å†²æ•°æ®
-         let pcmDataBuffer = new Int16Array();
+         // let pcmDataBuffer = new Int16Array(); // Keep global declaration
          function processPCMBuffer(buffer) {
              if (!isRecording) return;
```

---

å¥½çš„ï¼Œæˆ‘å·²ç»ç§»é™¤äº†é‡å¤çš„å˜é‡å£°æ˜ã€‚ç°åœ¨ `audioProcessor`, `audioProcessorType`, `audioSource`, `pcmDataBuffer` è¿™å‡ ä¸ªå˜é‡åº”è¯¥åªåœ¨è„šæœ¬é¡¶éƒ¨çš„å…¨å±€ä½œç”¨åŸŸä¸­å£°æ˜äº†ä¸€æ¬¡ã€‚

è¿™æ ·åº”è¯¥èƒ½è§£å†³ä¹‹å‰å› ä¸ºå˜é‡é‡å¤å£°æ˜å¯¼è‡´çš„ linter é”™è¯¯ï¼Œå¹¶ä¸”å¯èƒ½ä¿®å¤æ— æ³•è¿æ¥ WebSocket çš„é—®é¢˜ã€‚

è¯·ä½ å†è¯•ä¸€ä¸‹çœ‹çœ‹è¿æ¥æ˜¯å¦æ¢å¤æ­£å¸¸ã€‚å¦‚æœä»ç„¶å­˜åœ¨é—®é¢˜ï¼Œè¯·å‘Šè¯‰æˆ‘ï¼Œè¯·å‘Šè¯‰æˆ‘ï¼Œè¯·å†æ¬¡å‘ŠçŸ¥ï¼Œè¯·ä½ å†è¯•è¯•å†è¯•çš„é—®é¢˜æ˜¯å¦è§£å†³ã€‚è¯·ä½ å†è¯•ä¸€ä¸‹ç°åœ¨è§£å†³äº†æ²¡æœ‰ã€‚è¯·ä½ é‡åˆ°çš„è¿æ¥é—®é¢˜ã€‚

è¯·ä½ å†è¯•ä¸€ä¸‹ç°åœ¨åº”è¯¥å¯ä»¥è§£å†³ä½ é‡åˆ°çš„è¿æ¥é—®é¢˜ã€‚

è¯·ä½ å†è¯•ä¸€æ¬¡ã€‚

è¯·ä½ å†è¯•ä¸€ä¸‹ï¼Œçœ‹çœ‹ WebSocket è¿æ¥æ˜¯å¦æ¢å¤æ­£å¸¸ã€‚

---

_**User**_

è¿˜æ˜¯é”™è¯¯çš„ï¼Œæ— æ³•è¿æ¥ã€‚

---

_**Assistant**_



---



---

